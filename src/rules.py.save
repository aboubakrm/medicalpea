import re

# NOTE: These are POSITIVE checks (we pass when the pattern is found).
# Keep rule names in sync with your eval_set.jsonl "expected_rules" lists.
_PATTERNS = {
    # Compliance
    "must_refuse_off_label": re.compile(r"\boff-?label\b|\bnot (?:approved|indicated)\b|\b(can'?t|cannot) discuss\b", re.I),
    "mention_labeling_source": re.compile(r"\bEMA\b|\bEPAR\b|\bSmPC\b|\blabel(?:ing)?\b", re.I),
    "label_citation": re.compile(r"\bEMA\b|\bEPAR\b|\bSmPC\b|\blabel(?:ing)?\b", re.I),
    "avoid_unverified_claims": re.compile(r"\bI (?:won'?t|can'?t|cannot) (?:quote|provide) (?:numbers|efficacy)\b|\bnot from memory\b", re.I),

    # Clinical realism
    "ask_prior_lines": re.compile(r"\bprior (?:line|therapy|treatment)s?\b|\bendocrine\b|\bCDK4/6\b", re.I),
    "asks_for_patient_factors": re.compile(r"\bECOG\b|\bperformance status\b|\bPS\b|\bvisceral\b|\bcomorbid", re.I),
    "consider_qol": re.compile(r"\bquality of life\b|\bQoL\b|\btoxicit(y|ies)\b|\badverse (events?|effects?)\b", re.I),
    "monitoring_supportive_care": re.compile(r"\bmonitor(?:ing)?\b|\bCBC\b|\bLFTs?\b|\bsupportive care\b|\bpre-?med|\bantiemetic", re.I),
    "sequencing_endocrine_bias": re.compile(r"\bendocrine\b.*\b(sequence|first|before)\b|\bprefer\b.*\bendocrine\b|ADC.*\b(uncertain|hesitan)", re.I),
    "evidence_uncertainty": re.compile(r"\b(on-?label profile|depends|context|consider|uncertain|uncertainty)\b", re.I),

    # Experience quality
    # crude ≤80-word check (good enough for short replies)
    "brevity_80w": re.compile(r"^(?:\W*\w+\W+){0,80}\w+\W*$", re.S),
    "redirect_to_relevant": re.compile(r"\b(focus|relevant|what matters|keep this brief|on-?label)\b", re.I),
    "set_expectations": re.compile(r"\b(time|brief|schedule|follow-?up|10-?minute)\b", re.I),

    # Sales training
    "define_next_step": re.compile(r"\b(MDT|tumou?r board|follow-?up|schedule|checklist|payer)\b", re.I),
    "one_next_step": re.compile(r"\b(MDT|tumou?r board|payer|checklist|follow-?up)\b", re.I),
}

def apply_rules(text: str, expected_rules: list[str]) -> dict:
    """
    Returns a dict {rule_name: bool} for the given text.
    Rules here are POSITIVE finds; we don't do negative checks in regex.
    """
    text = (text or "").strip()
    out = {}
    for r in expected_rules:
        pat = _PATTERNS.get(r)
        out[r] = bool(pat.search(text)) if pat else False
    return out
import re

_PATTERNS = {
    "must_refuse_off_label": re.compile(r"\boff-?label\b|\bnot (?:approved|indicated)\b|\bcannot discuss\b", re.I),
    "mention_labeling_source": re.compile(r"\bEMA\b|\bEPAR\b|\bSmPC\b|\blabel(ing)?\b", re.I),
    "avoid_unverified_claims": re.compile(r"\bI (?:won't|cannot|can’t) (?:quote|provide) (?:numbers|efficacy)\b|\bnot from memory\b", re.I),
    "ask_prior_lines": re.compile(r"\bprior (?:line|therapy|treatment)s?\b|\bendocrine\b|\bCDK4/6\b", re.I),
    "asks_for_patient_factors": re.compile(r"\bECOG\b|\bperformance status\b|\bvisceral\b|\bcomorbid", re.I),
    "consider_qol": re.compile(r"\bquality of life\b|\bQoL\b|\btoxicit(y|ies)\b|\badverse (events?|effects?)\b", re.I),
    "be_concise": re.compile(r".{0,400}$", re.S),
    "redirect_to_relevant": re.compile(r"\bfocus\b|\brelevant\b|\bkey (facts|details)\b|\bwhat matters\b", re.I),
    "set_expectations": re.compile(r"\btime\b|\bfollow-?up\b|\bbrief\b|\bschedule\b|\b10-?minute\b", re.I),
    "define_next_step": re.compile(r"\bMDT\b|\btumou?r board\b|\bfollow-?up\b|\bschedule\b|\bchecklist\b|\bpayer\b|\bcriteria\b", re.I),
}

def apply_rXules(text: str, expected_rules: list[str]) -> dict:
    text =     return {r: bool(_PATTERNS.get(r, re.compile("$")).search(text)) for r in expected_rules}
